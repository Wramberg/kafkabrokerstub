#include "kafka_broker_stub/produce.hpp"
#include "kafka_broker_stub/produce.hpp"

#include "test_common.hpp"

namespace kbs = kafka_broker_stub;

class produce_test : public kbs::test::suite
{
public:
	produce_test(const std::string& name): suite(name) { }

private:
	void request_test()
	{
		// A modified produce request generated by librdkafka and recorded using tcpdump
		uint8_t req[] = {
			0x00, 0x00, 0x00, 0x52, // Length of message 82 bytes
			0x00, 0x00, // Api key 0
			0x00, 0x00, // Api version 0
			0x00, 0x00, 0x00, 0x03, // Correlation id 3
			0x00, 0x07, 0x72, 0x64, 0x6b, 0x61, 0x66, 0x6b, 0x61, // client id string
			0x00, 0x01, // acks
			0x00, 0x00, 0x13, 0x88, // timeout
			0x00, 0x00, 0x00, 0x01, // topic data array start
				0x00, 0x04, 0x74, 0x65, 0x73, 0x74, // topic name string
				0x00, 0x00, 0x00, 0x01, // data array start
					0x00, 0x00, 0x00, 0x08, // partition id
					0x00, 0x00, 0x00, 0x25, // length of binary message (rest of payload)
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, // offset
						0x00, 0x00, 0x00, 0x19, // message size
						0xa6, 0xb1, 0x36, 0x2b, // crc
						0xFF, // magic byte
						0xEE, // attributes
						0xff, 0xff, 0xff, 0xff, // key byte array
				   	0x00, 0x00, 0x00, 0x0b, // value bytearray length (rest of payload)
				   		0x74, 0x65, 0x73, 0x74, 0x6d, 0x65,
				   		0x73, 0x73, 0x61, 0x67, 0x65};

      // Decode the request - note that the first four bytes describe the length
      // of the message which is not part of the request
		kbs::produce::request_v0 produce_req;
		ASSERT_EQ(produce_req.deserialize(req+4), const_cast<const uint8_t*>(req+4+82));
		ASSERT_EQ(produce_req.acks(), kbs::primitive::int16(1));
		ASSERT_EQ(produce_req.timeout(), kbs::primitive::int32(5000));
		ASSERT_EQ(produce_req.topic_records().size(), static_cast<size_t>(1));

		const kbs::produce::topic_record& top = produce_req.topic_records()[0];
		ASSERT_EQ(top.topic_name().std_str(), std::string("test"));
		ASSERT_EQ(top.partition_records().size(), static_cast<size_t>(1));

		const kbs::produce::partition_record& part = top.partition_records()[0];
		ASSERT_EQ(part.partition(), kbs::primitive::int32(8));

		const kbs::primitive::bytearray& payload = part.record();
		ASSERT_EQ(payload.size(), static_cast<size_t>(37));

		// Decode the pyload to a message
		kbs::produce::message msg;
		msg.deserialize(payload.data());
		ASSERT_EQ(static_cast<int64_t>(msg.offset()), static_cast<int64_t>(9));
		ASSERT_EQ(msg.message_size(), kbs::primitive::int32(25));
		ASSERT_EQ(msg.crc(), kbs::primitive::int32(-1498335701));
		ASSERT_EQ(msg.magicbyte(), kbs::primitive::int8(-1));
		ASSERT_EQ(msg.attributes(), kbs::primitive::int8(-18));
		ASSERT_EQ(msg.key().size(), static_cast<size_t>(0));
		ASSERT_EQ(msg.value().size(), static_cast<size_t>(11));
		ASSERT_EQ(msg.value().std_str(), std::string("testmessage"));
	}

	void response_test()
	{
		// Make partition result array
		kbs::produce::partition_result part_res(8, 7, 1);
		kbs::primitive::array<kbs::produce::partition_result> part_arr;
		part_arr.push_back(part_res);

		// Make topic result array
		kbs::produce::topic_result topic_res(kbs::primitive::string("test"), part_arr);
		kbs::primitive::array<kbs::produce::topic_result> topic_arr;
		topic_arr.push_back(topic_res);

		// Make response
		kbs::produce::response_v0 resp(3, topic_arr);

		// Serialize response into buffer
		uint8_t data[1024];
		ASSERT_EQ(resp.serialize(data), static_cast<uint8_t*>(data+32));
		ASSERT_EQ(resp.serial_size(), static_cast<size_t>(32));

		// Check the data against a modified tcpdump capture from an actual kafka broker
		uint8_t cmp[] = {
			0x00, 0x00, 0x00, 0x03, // Correlation ID
			0x00, 0x00, 0x00, 0x01, // Array of responses start
				0x00, 0x04, 0x74, 0x65, 0x73, 0x74, // Topic name string
				0x00, 0x00, 0x00, 0x01, // Array of partition responses start
					0x00, 0x00, 0x00, 0x08, // Partition ID
					0x00, 0x07, // Partition error code
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 // Offset
		};

		ASSERT_EQ(memcmp(data, cmp, sizeof(cmp)), 0);
	}

	void default_ctor_tests()
	{
		// Just some silly tests of the default ctor for code coverage
		kbs::produce::topic_result topic_result;
		ASSERT_EQ(topic_result.serial_size(), static_cast<size_t>(6));

		kbs::produce::partition_result partition_result;
		ASSERT_EQ(partition_result.serial_size(), static_cast<size_t>(14));
	}

	void tests()
	{
		request_test();
		response_test();
		default_ctor_tests();
	}
};

int main()
{
	produce_test suite("Produce unittests");
	suite.execute_tests();
	return 0;
}
