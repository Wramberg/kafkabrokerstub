#include "kafka_broker_stub/metadata.hpp"
#include "kafka_broker_stub/metadata.hpp"

#include "test_common.hpp"

namespace kbs = kafka_broker_stub;

class metadata_test : public kbs::test::suite
{
public:
	metadata_test(const std::string& name): suite(name) { }

private:
	void request_test()
	{
		// A metadata request generated by librdkafka and recorded using tcpdump
		uint8_t req[] = {0x00, 0x00, 0x00, 0x1b, 0x00, 0x03, 0x00, 0x00, 0x00,
			              0x00, 0x00, 0x02, 0x00, 0x07, 0x72, 0x64, 0x6b, 0x61,
			              0x66, 0x6b, 0x61, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04,
			              0x74, 0x65, 0x73, 0x74};

		// Decode the request - note that the first four bytes describe the length
		// of the message which is not part of the request
		kbs::metadata::request_v0 meta_req;
		ASSERT_EQ(meta_req.deserialize(req+4), const_cast<const uint8_t*>(req+4+27));
		ASSERT_EQ(meta_req.topics().size(), static_cast<size_t>(1));
		ASSERT_EQ(meta_req.topics()[0].std_str(), std::string("test"));
	}

	void response_test()
	{
		// Make broker array
		kbs::metadata::broker broker(1, "localhost", 9092);
		kbs::primitive::array<kbs::metadata::broker> broker_arr;
		broker_arr.push_back(broker);

		// Make array containing leader id for replica and isr array
		kbs::primitive::array<kbs::primitive::int32> replica_isr_arr;
		replica_isr_arr.push_back(1);

		// Make partition metadata array
		kbs::metadata::partition part(2, 3, 1, replica_isr_arr, replica_isr_arr);
		kbs::primitive::array<kbs::metadata::partition> part_meta_arr;
		part_meta_arr.push_back(part);

		// Make topic metadata array
		kbs::metadata::topic topic(7, kbs::primitive::string("test"), part_meta_arr);
		kbs::primitive::array<kbs::metadata::topic> topic_arr;
		topic_arr.push_back(topic);

		// Make metadata response
		kbs::metadata::response_v0 resp(1, broker_arr, topic_arr);

		// Serialize response
		uint8_t data[1024];
		ASSERT_EQ(resp.serialize(data), static_cast<uint8_t*>(data+69));
		ASSERT_EQ(resp.serial_size(), static_cast<size_t>(69));

		// Check the data against a modified tcpdump capture from an actual kafka broker
		uint8_t cmp[] = {
			0x00, 0x00, 0x00, 0x01, // Correlation ID
			0x00, 0x00, 0x00, 0x01, // Broker array start (1 element)
				0x00, 0x00, 0x00, 0x01, // Broker ID
				0x00, 0x09, // Broker address string length
				0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, // string
				0x00, 0x00, 0x23, 0x84, // Broker port
			0x00, 0x00, 0x00, 0x01, // Topic metadata array start (1 element)
				0x00, 0x07, // Topic error code
				0x00, 0x04, // Topic name string length
				0x74, 0x65, 0x73, 0x74, // string
				0x00, 0x00, 0x00, 0x01, // Partition metadata array start (1 element)
					0x00, 0x02, // Partition error code
					0x00, 0x00, 0x00, 0x03, // Partition id
					0x00, 0x00, 0x00, 0x01, // Leader ID
					0x00, 0x00, 0x00, 0x01, // Replica array start (1 element)
						0x00, 0x00, 0x00, 0x01, // Broker id
					0x00, 0x00, 0x00, 0x01, // ISR array start (1 elemeent)
						0x00, 0x00, 0x00, 0x01 // Broker id
		};

		ASSERT_EQ(memcmp(data, cmp, sizeof(cmp)), 0);
	}

	void default_ctor_tests()
	{
		// Just some silly tests of the default ctor for code coverage
		kbs::metadata::broker broker;
		ASSERT_EQ(broker.serial_size(), static_cast<size_t>(10));

		kbs::metadata::partition partition;
		ASSERT_EQ(partition.serial_size(), static_cast<size_t>(18));

		kbs::metadata::topic topic;
		ASSERT_EQ(topic.serial_size(), static_cast<size_t>(8));
	}

	void tests()
	{
		request_test();
		response_test();
		default_ctor_tests();
	}
};

int main()
{
	metadata_test suite("Metadata unittests");
	suite.execute_tests();
	return 0;
}
